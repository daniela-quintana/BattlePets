{"ast":null,"code":"import { shipTypes } from \"../constants/constants\";\n/*\n* Method generates battlefield with placed ships\n* */\n\nexport const getBattleField = () => {\n  let battleField = [10];\n\n  for (let i = 0; i < 10; i++) {\n    battleField[i] = [10];\n\n    for (let j = 0; j < 10; j++) {\n      battleField[i][j] = null;\n    }\n  }\n\n  for (let i = 0; i < shipTypes.length; i++) {\n    battleField = generateShipPositions(shipTypes[i], battleField);\n  }\n\n  return battleField;\n};\n/*\n* Generates random ship positions\n*\n* @param1 initial ship\n* @param2 initial battlefield\n*\n* @returns updated battlefield\n* */\n\nconst generateShipPositions = (ship, battleField) => {\n  let shipStartPosition = null;\n  let continueLoop = true;\n\n  while (continueLoop) {\n    shipStartPosition = getRandomCoordinate();\n\n    if (positionIsFree(battleField, shipStartPosition)) {\n      let x = shipStartPosition[0];\n      let y = shipStartPosition[1];\n      let directions = getDirections();\n      battleField[x][y] = ship.id * 100;\n      battleField = refillNeighbourCells(battleField, x, y, ship.id);\n\n      for (let i = 0; i < directions.length; i++) {\n        let tempBattlefield = makeClone(battleField);\n        let newBattleField = tryDirections(directions[i], ship, shipStartPosition, tempBattlefield);\n\n        if (newBattleField !== null) {\n          continueLoop = false;\n          battleField = [...newBattleField];\n          break;\n        } else {\n          tempBattlefield = newBattleField = null;\n        }\n      }\n    }\n  }\n\n  return battleField;\n};\n/*\n*  Method tries different direction of ship placement\n*    @param1 direction\n*    @param2 initialship\n*    @param3 start position\n*    @param4 initial battlefield\n*\n*    @returns new battlefield or null\n* */\n\n\nfunction tryDirections(direction, ship, shipStartPosition, battleField) {\n  let x = shipStartPosition[0];\n  let y = shipStartPosition[1];\n  let wrongDirection = false;\n\n  for (let i = 1; i < ship.size; i++) {\n    switch (direction) {\n      case 0:\n        if (y + i > 9) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x, y + i]) || battleField[x][y + i] === ship.id) {\n          battleField[x][y + i] = ship.id * 100;\n          refillNeighbourCells(battleField, x, y + i, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n\n      case 1:\n        if (x + i > 9) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x + i, y]) || battleField[x + i][y] === ship.id) {\n          battleField[x + i][y] = ship.id * 100;\n          refillNeighbourCells(battleField, x + i, y, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n\n      case 2:\n        if (y - i < 0) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x, y - i]) || battleField[x][y - i] === ship.id) {\n          battleField[x][y - i] = ship.id * 100;\n          refillNeighbourCells(battleField, x, y - i, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n\n      case 3:\n        if (x - i < 0) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x - i, y]) || battleField[x - i][y] === ship.id) {\n          battleField[x - i][y] = ship.id * 100;\n          refillNeighbourCells(battleField, x - i, y, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n\n  if (wrongDirection) {\n    return null;\n  } else {\n    return battleField;\n  }\n}\n/*\n*  Method marks neighbour cells of initial position on battlefield\n*\n*  @param1 initial battlefield\n*  @param2 x axis coordinate\n*  @param3 y axis coordinate\n*  @param4 initial ship id\n*\n*  @returns updated battleField\n* */\n\n\nconst refillNeighbourCells = (battleField, x, y, shipId) => {\n  if (y < 9 && battleField[x][y + 1] === null) {\n    battleField[x][y + 1] = shipId;\n  }\n\n  if (x < 9 && y < 9 && battleField[x + 1][y + 1] === null) {\n    battleField[x + 1][y + 1] = shipId;\n  }\n\n  if (x < 9 && battleField[x + 1][y] === null) {\n    battleField[x + 1][y] = shipId;\n  }\n\n  if (x < 9 && y > 0 && battleField[x + 1][y - 1] === null) {\n    battleField[x + 1][y - 1] = shipId;\n  }\n\n  if (y > 0 && battleField[x][y - 1] === null) {\n    battleField[x][y - 1] = shipId;\n  }\n\n  if (x > 0 && y > 0 && battleField[x - 1][y - 1] === null) {\n    battleField[x - 1][y - 1] = shipId;\n  }\n\n  if (x > 0 && battleField[x - 1][y] === null) {\n    battleField[x - 1][y] = shipId;\n  }\n\n  if (x > 0 && y < 9 && battleField[x - 1][y + 1] === null) {\n    battleField[x - 1][y + 1] = shipId;\n  }\n\n  return battleField;\n};\n/*\n*  Checks position\n*\n*  @param1 initial battlefield\n*  @param2 initial positin\n*\n*  @return true if position is free\n* */\n\n\nconst positionIsFree = (battleField, position) => {\n  let x = position[0];\n  let y = position[1];\n  return !(battleField[x][y] > 0);\n};\n/*\n* Returns random sequence of ship placing directions\n* */\n\n\nconst getDirections = () => {\n  let directions = [];\n\n  for (let i = 0; directions.length < 4; i++) {\n    let number = getRandomNumber(4);\n\n    if (directions.indexOf(number) === -1) {\n      directions.push(number);\n    }\n  }\n\n  return directions;\n};\n/*\n* Returns random coordinate\n* */\n\n\nconst getRandomCoordinate = () => {\n  const max = 9;\n  return [Math.floor(Math.random() * max), Math.floor(Math.random() * max)];\n};\n/*\n* Returns random number in range from 0 to @param 'max'\n* */\n\n\nconst getRandomNumber = max => {\n  return Math.floor(Math.random() * max);\n};\n/*\n*  Makes clone of battleField\n*\n*  @param initial battleField\n*\n*  @returns clone of initial battleField\n* */\n\n\nexport const makeClone = battleField => {\n  let clone = [10];\n\n  for (let i = 0; i < 10; i++) {\n    clone[i] = [10];\n\n    for (let j = 0; j < 10; j++) {\n      clone[i][j] = battleField[i][j];\n    }\n  }\n\n  return clone;\n};","map":{"version":3,"sources":["/Users/osx/Box Sync/Laboratoria/Proyectos/BattlePets/src/app/helpers/generateBattleField.js"],"names":["shipTypes","getBattleField","battleField","i","j","length","generateShipPositions","ship","shipStartPosition","continueLoop","getRandomCoordinate","positionIsFree","x","y","directions","getDirections","id","refillNeighbourCells","tempBattlefield","makeClone","newBattleField","tryDirections","direction","wrongDirection","size","shipId","position","number","getRandomNumber","indexOf","push","max","Math","floor","random","clone"],"mappings":"AAAA,SAASA,SAAT,QAA0B,wBAA1B;AAEA;;;;AAGA,OAAO,MAAMC,cAAc,GAAG,MAAM;AAClC,MAAIC,WAAW,GAAG,CAAC,EAAD,CAAlB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BD,IAAAA,WAAW,CAACC,CAAD,CAAX,GAAiB,CAAC,EAAD,CAAjB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BF,MAAAA,WAAW,CAACC,CAAD,CAAX,CAAeC,CAAf,IAAoB,IAApB;AACD;AACF;;AACD,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACK,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AACzCD,IAAAA,WAAW,GAAGI,qBAAqB,CAACN,SAAS,CAACG,CAAD,CAAV,EAAeD,WAAf,CAAnC;AACD;;AACD,SAAOA,WAAP;AACD,CAZM;AAcP;;;;;;;;;AAQA,MAAMI,qBAAqB,GAAG,CAACC,IAAD,EAAOL,WAAP,KAAuB;AACnD,MAAIM,iBAAiB,GAAG,IAAxB;AACA,MAAIC,YAAY,GAAG,IAAnB;;AACA,SAAOA,YAAP,EAAqB;AACnBD,IAAAA,iBAAiB,GAAGE,mBAAmB,EAAvC;;AACA,QAAIC,cAAc,CAACT,WAAD,EAAcM,iBAAd,CAAlB,EAAoD;AAClD,UAAII,CAAC,GAAGJ,iBAAiB,CAAC,CAAD,CAAzB;AACA,UAAIK,CAAC,GAAGL,iBAAiB,CAAC,CAAD,CAAzB;AACA,UAAIM,UAAU,GAAGC,aAAa,EAA9B;AACAb,MAAAA,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAf,IAAoBN,IAAI,CAACS,EAAL,GAAU,GAA9B;AACAd,MAAAA,WAAW,GAAGe,oBAAoB,CAACf,WAAD,EAAcU,CAAd,EAAiBC,CAAjB,EAAoBN,IAAI,CAACS,EAAzB,CAAlC;;AAEA,WAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,UAAU,CAACT,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAE1C,YAAIe,eAAe,GAAGC,SAAS,CAACjB,WAAD,CAA/B;AACA,YAAIkB,cAAc,GAAGC,aAAa,CAACP,UAAU,CAACX,CAAD,CAAX,EAAgBI,IAAhB,EAAsBC,iBAAtB,EAAyCU,eAAzC,CAAlC;;AACA,YAAIE,cAAc,KAAK,IAAvB,EAA6B;AAC3BX,UAAAA,YAAY,GAAG,KAAf;AACAP,UAAAA,WAAW,GAAG,CAAC,GAAGkB,cAAJ,CAAd;AACA;AACD,SAJD,MAIO;AACLF,UAAAA,eAAe,GAAGE,cAAc,GAAG,IAAnC;AACD;AACF;AACF;AACF;;AACD,SAAOlB,WAAP;AACD,CA3BD;AA6BA;;;;;;;;;;;AASA,SAASmB,aAAT,CAAuBC,SAAvB,EAAkCf,IAAlC,EAAwCC,iBAAxC,EAA2DN,WAA3D,EAAwE;AACtE,MAAIU,CAAC,GAAGJ,iBAAiB,CAAC,CAAD,CAAzB;AACA,MAAIK,CAAC,GAAGL,iBAAiB,CAAC,CAAD,CAAzB;AACA,MAAIe,cAAc,GAAG,KAArB;;AAEA,OAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,IAAI,CAACiB,IAAzB,EAA+BrB,CAAC,EAAhC,EAAoC;AAClC,YAAQmB,SAAR;AACE,WAAK,CAAL;AACE,YAAIT,CAAC,GAAGV,CAAJ,GAAQ,CAAZ,EAAe;AACboB,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD,SAHD,MAGO,IAAIZ,cAAc,CAACT,WAAD,EAAc,CAACU,CAAD,EAAIC,CAAC,GAAGV,CAAR,CAAd,CAAd,IAA2CD,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAGV,CAAnB,MAA0BI,IAAI,CAACS,EAA9E,EAAkF;AACvFd,UAAAA,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAGV,CAAnB,IAAwBI,IAAI,CAACS,EAAL,GAAU,GAAlC;AACAC,UAAAA,oBAAoB,CAACf,WAAD,EAAcU,CAAd,EAAiBC,CAAC,GAAGV,CAArB,EAAwBI,IAAI,CAACS,EAA7B,CAApB;AACAO,UAAAA,cAAc,GAAG,KAAjB;AACA;AACD,SALM,MAKA;AACLA,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD;;AACH,WAAK,CAAL;AACE,YAAIX,CAAC,GAAGT,CAAJ,GAAQ,CAAZ,EAAe;AACboB,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD,SAHD,MAGO,IAAIZ,cAAc,CAACT,WAAD,EAAc,CAACU,CAAC,GAAGT,CAAL,EAAQU,CAAR,CAAd,CAAd,IAA2CX,WAAW,CAACU,CAAC,GAAGT,CAAL,CAAX,CAAmBU,CAAnB,MAA0BN,IAAI,CAACS,EAA9E,EAAkF;AACvFd,UAAAA,WAAW,CAACU,CAAC,GAAGT,CAAL,CAAX,CAAmBU,CAAnB,IAAwBN,IAAI,CAACS,EAAL,GAAU,GAAlC;AACAC,UAAAA,oBAAoB,CAACf,WAAD,EAAcU,CAAC,GAAGT,CAAlB,EAAqBU,CAArB,EAAwBN,IAAI,CAACS,EAA7B,CAApB;AACAO,UAAAA,cAAc,GAAG,KAAjB;AACA;AACD,SALM,MAKA;AACLA,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD;;AACH,WAAK,CAAL;AACE,YAAIV,CAAC,GAAGV,CAAJ,GAAQ,CAAZ,EAAe;AACboB,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD,SAHD,MAGO,IAAIZ,cAAc,CAACT,WAAD,EAAc,CAACU,CAAD,EAAIC,CAAC,GAAGV,CAAR,CAAd,CAAd,IAA2CD,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAGV,CAAnB,MAA0BI,IAAI,CAACS,EAA9E,EAAkF;AACvFd,UAAAA,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAGV,CAAnB,IAAwBI,IAAI,CAACS,EAAL,GAAU,GAAlC;AACAC,UAAAA,oBAAoB,CAACf,WAAD,EAAcU,CAAd,EAAiBC,CAAC,GAAGV,CAArB,EAAwBI,IAAI,CAACS,EAA7B,CAApB;AACAO,UAAAA,cAAc,GAAG,KAAjB;AACA;AACD,SALM,MAKA;AACLA,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD;;AACH,WAAK,CAAL;AACE,YAAIX,CAAC,GAAGT,CAAJ,GAAQ,CAAZ,EAAe;AACboB,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD,SAHD,MAGO,IAAIZ,cAAc,CAACT,WAAD,EAAc,CAACU,CAAC,GAAGT,CAAL,EAAQU,CAAR,CAAd,CAAd,IAA2CX,WAAW,CAACU,CAAC,GAAGT,CAAL,CAAX,CAAmBU,CAAnB,MAA0BN,IAAI,CAACS,EAA9E,EAAkF;AACvFd,UAAAA,WAAW,CAACU,CAAC,GAAGT,CAAL,CAAX,CAAmBU,CAAnB,IAAwBN,IAAI,CAACS,EAAL,GAAU,GAAlC;AACAC,UAAAA,oBAAoB,CAACf,WAAD,EAAcU,CAAC,GAAGT,CAAlB,EAAqBU,CAArB,EAAwBN,IAAI,CAACS,EAA7B,CAApB;AACAO,UAAAA,cAAc,GAAG,KAAjB;AACA;AACD,SALM,MAKA;AACLA,UAAAA,cAAc,GAAG,IAAjB;AACA;AACD;;AAEH;AACE;AAvDJ;AAyDD;;AACD,MAAIA,cAAJ,EAAoB;AAClB,WAAO,IAAP;AACD,GAFD,MAEO;AACL,WAAOrB,WAAP;AACD;AACF;AAED;;;;;;;;;;;;AAUA,MAAMe,oBAAoB,GAAG,CAACf,WAAD,EAAcU,CAAd,EAAiBC,CAAjB,EAAoBY,MAApB,KAA+B;AAC1D,MAAIZ,CAAC,GAAG,CAAJ,IAASX,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAG,CAAnB,MAA0B,IAAvC,EAA6C;AAC3CX,IAAAA,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAG,CAAnB,IAAwBY,MAAxB;AACD;;AACD,MAAIb,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBX,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,MAA8B,IAApD,EAA0D;AACxDX,IAAAA,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,IAA4BY,MAA5B;AACD;;AACD,MAAIb,CAAC,GAAG,CAAJ,IAASV,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAnB,MAA0B,IAAvC,EAA6C;AAC3CX,IAAAA,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAnB,IAAwBY,MAAxB;AACD;;AACD,MAAIb,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBX,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,MAA8B,IAApD,EAA0D;AACxDX,IAAAA,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,IAA4BY,MAA5B;AACD;;AACD,MAAIZ,CAAC,GAAG,CAAJ,IAASX,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAG,CAAnB,MAA0B,IAAvC,EAA6C;AAC3CX,IAAAA,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAC,GAAG,CAAnB,IAAwBY,MAAxB;AACD;;AACD,MAAIb,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBX,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,MAA8B,IAApD,EAA0D;AACxDX,IAAAA,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,IAA4BY,MAA5B;AACD;;AACD,MAAIb,CAAC,GAAG,CAAJ,IAASV,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAnB,MAA0B,IAAvC,EAA6C;AAC3CX,IAAAA,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAnB,IAAwBY,MAAxB;AACD;;AACD,MAAIb,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBX,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,MAA8B,IAApD,EAA0D;AACxDX,IAAAA,WAAW,CAACU,CAAC,GAAG,CAAL,CAAX,CAAmBC,CAAC,GAAG,CAAvB,IAA4BY,MAA5B;AACD;;AACD,SAAOvB,WAAP;AACD,CA1BD;AA4BA;;;;;;;;;;AAQA,MAAMS,cAAc,GAAG,CAACT,WAAD,EAAcwB,QAAd,KAA2B;AAChD,MAAId,CAAC,GAAGc,QAAQ,CAAC,CAAD,CAAhB;AACA,MAAIb,CAAC,GAAGa,QAAQ,CAAC,CAAD,CAAhB;AACA,SAAO,EAAExB,WAAW,CAACU,CAAD,CAAX,CAAeC,CAAf,IAAoB,CAAtB,CAAP;AACD,CAJD;AAMA;;;;;AAGA,MAAME,aAAa,GAAG,MAAM;AAC1B,MAAID,UAAU,GAAG,EAAjB;;AACA,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBW,UAAU,CAACT,MAAX,GAAoB,CAApC,EAAuCF,CAAC,EAAxC,EAA4C;AAC1C,QAAIwB,MAAM,GAAGC,eAAe,CAAC,CAAD,CAA5B;;AACA,QAAId,UAAU,CAACe,OAAX,CAAmBF,MAAnB,MAA+B,CAAC,CAApC,EAAuC;AACrCb,MAAAA,UAAU,CAACgB,IAAX,CAAgBH,MAAhB;AACD;AACF;;AACD,SAAOb,UAAP;AACD,CATD;AAWA;;;;;AAGA,MAAMJ,mBAAmB,GAAG,MAAM;AAChC,QAAMqB,GAAG,GAAG,CAAZ;AACA,SAAO,CAACC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBH,GAA3B,CAAD,EAAkCC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBH,GAA3B,CAAlC,CAAP;AACD,CAHD;AAKA;;;;;AAGA,MAAMH,eAAe,GAAIG,GAAD,IAAS;AAC/B,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBH,GAA3B,CAAP;AACD,CAFD;AAIA;;;;;;;;;AAOA,OAAO,MAAMZ,SAAS,GAAIjB,WAAD,IAAiB;AACxC,MAAIiC,KAAK,GAAG,CAAC,EAAD,CAAZ;;AACA,OAAK,IAAIhC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BgC,IAAAA,KAAK,CAAChC,CAAD,CAAL,GAAW,CAAC,EAAD,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3B+B,MAAAA,KAAK,CAAChC,CAAD,CAAL,CAASC,CAAT,IAAcF,WAAW,CAACC,CAAD,CAAX,CAAeC,CAAf,CAAd;AACD;AACF;;AACD,SAAO+B,KAAP;AACD,CATM","sourcesContent":["import { shipTypes } from \"../constants/constants\";\n\n/*\n* Method generates battlefield with placed ships\n* */\nexport const getBattleField = () => {\n  let battleField = [10];\n  for (let i = 0; i < 10; i++) {\n    battleField[i] = [10];\n    for (let j = 0; j < 10; j++) {\n      battleField[i][j] = null;\n    }\n  }\n  for (let i = 0; i < shipTypes.length; i++) {\n    battleField = generateShipPositions(shipTypes[i], battleField);\n  }\n  return battleField;\n};\n\n/*\n* Generates random ship positions\n*\n* @param1 initial ship\n* @param2 initial battlefield\n*\n* @returns updated battlefield\n* */\nconst generateShipPositions = (ship, battleField) => {\n  let shipStartPosition = null;\n  let continueLoop = true;\n  while (continueLoop) {\n    shipStartPosition = getRandomCoordinate();\n    if (positionIsFree(battleField, shipStartPosition)) {\n      let x = shipStartPosition[0];\n      let y = shipStartPosition[1];\n      let directions = getDirections();\n      battleField[x][y] = ship.id * 100;\n      battleField = refillNeighbourCells(battleField, x, y, ship.id);\n\n      for (let i = 0; i < directions.length; i++) {\n\n        let tempBattlefield = makeClone(battleField);\n        let newBattleField = tryDirections(directions[i], ship, shipStartPosition, tempBattlefield);\n        if (newBattleField !== null) {\n          continueLoop = false;\n          battleField = [...newBattleField];\n          break;\n        } else {\n          tempBattlefield = newBattleField = null;\n        }\n      }\n    }\n  }\n  return battleField;\n};\n\n/*\n*  Method tries different direction of ship placement\n*    @param1 direction\n*    @param2 initialship\n*    @param3 start position\n*    @param4 initial battlefield\n*\n*    @returns new battlefield or null\n* */\nfunction tryDirections(direction, ship, shipStartPosition, battleField) {\n  let x = shipStartPosition[0];\n  let y = shipStartPosition[1];\n  let wrongDirection = false;\n\n  for (let i = 1; i < ship.size; i++) {\n    switch (direction) {\n      case 0:\n        if (y + i > 9) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x, y + i]) || battleField[x][y + i] === ship.id) {\n          battleField[x][y + i] = ship.id * 100;\n          refillNeighbourCells(battleField, x, y + i, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n      case 1:\n        if (x + i > 9) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x + i, y]) || battleField[x + i][y] === ship.id) {\n          battleField[x + i][y] = ship.id * 100;\n          refillNeighbourCells(battleField, x + i, y, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n      case 2:\n        if (y - i < 0) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x, y - i]) || battleField[x][y - i] === ship.id) {\n          battleField[x][y - i] = ship.id * 100;\n          refillNeighbourCells(battleField, x, y - i, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n      case 3:\n        if (x - i < 0) {\n          wrongDirection = true;\n          break;\n        } else if (positionIsFree(battleField, [x - i, y]) || battleField[x - i][y] === ship.id) {\n          battleField[x - i][y] = ship.id * 100;\n          refillNeighbourCells(battleField, x - i, y, ship.id);\n          wrongDirection = false;\n          break;\n        } else {\n          wrongDirection = true;\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n  if (wrongDirection) {\n    return null;\n  } else {\n    return battleField;\n  }\n}\n\n/*\n*  Method marks neighbour cells of initial position on battlefield\n*\n*  @param1 initial battlefield\n*  @param2 x axis coordinate\n*  @param3 y axis coordinate\n*  @param4 initial ship id\n*\n*  @returns updated battleField\n* */\nconst refillNeighbourCells = (battleField, x, y, shipId) => {\n  if (y < 9 && battleField[x][y + 1] === null) {\n    battleField[x][y + 1] = shipId;\n  }\n  if (x < 9 && y < 9 && battleField[x + 1][y + 1] === null) {\n    battleField[x + 1][y + 1] = shipId;\n  }\n  if (x < 9 && battleField[x + 1][y] === null) {\n    battleField[x + 1][y] = shipId;\n  }\n  if (x < 9 && y > 0 && battleField[x + 1][y - 1] === null) {\n    battleField[x + 1][y - 1] = shipId;\n  }\n  if (y > 0 && battleField[x][y - 1] === null) {\n    battleField[x][y - 1] = shipId;\n  }\n  if (x > 0 && y > 0 && battleField[x - 1][y - 1] === null) {\n    battleField[x - 1][y - 1] = shipId;\n  }\n  if (x > 0 && battleField[x - 1][y] === null) {\n    battleField[x - 1][y] = shipId;\n  }\n  if (x > 0 && y < 9 && battleField[x - 1][y + 1] === null) {\n    battleField[x - 1][y + 1] = shipId;\n  }\n  return battleField;\n};\n\n/*\n*  Checks position\n*\n*  @param1 initial battlefield\n*  @param2 initial positin\n*\n*  @return true if position is free\n* */\nconst positionIsFree = (battleField, position) => {\n  let x = position[0];\n  let y = position[1];\n  return !(battleField[x][y] > 0);\n};\n\n/*\n* Returns random sequence of ship placing directions\n* */\nconst getDirections = () => {\n  let directions = [];\n  for (let i = 0; directions.length < 4; i++) {\n    let number = getRandomNumber(4);\n    if (directions.indexOf(number) === -1) {\n      directions.push(number);\n    }\n  }\n  return directions;\n};\n\n/*\n* Returns random coordinate\n* */\nconst getRandomCoordinate = () => {\n  const max = 9;\n  return [Math.floor(Math.random() * max), Math.floor(Math.random() * max)]\n};\n\n/*\n* Returns random number in range from 0 to @param 'max'\n* */\nconst getRandomNumber = (max) => {\n  return Math.floor(Math.random() * max)\n};\n\n/*\n*  Makes clone of battleField\n*\n*  @param initial battleField\n*\n*  @returns clone of initial battleField\n* */\nexport const makeClone = (battleField) => {\n  let clone = [10];\n  for (let i = 0; i < 10; i++) {\n    clone[i] = [10];\n    for (let j = 0; j < 10; j++) {\n      clone[i][j] = battleField[i][j];\n    }\n  }\n  return clone;\n};\n\n\n"]},"metadata":{},"sourceType":"module"}